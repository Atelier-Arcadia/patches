use semver::SemVerError;

use package::{Description as PackageDescription, Package};


/// Indicates how severe a vulnerability is.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum Severity {
  #[serde(rename = "unknown")]
  Unknown,
  #[serde(rename = "negligable")]
  Negligable,
  #[serde(rename = "low")]
  Low,
  #[serde(rename = "medium")]
  Medium,
  #[serde(rename = "high")]
  High,
  #[serde(rename = "critical")]
  Critical,
  #[serde(rename = "urgent")]
  Urgent,
}

/// A container for information describing a vulnerability that supports easy
/// serialization and deserialization.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Description {
  pub name: String,
  pub package: String,
  pub href: String,
  pub severity: Severity,
  pub fixes: Vec<PackageDescription>,
}

/// Describes a vulnerability, the package it affects, and any package versions
/// in which the vulnerability was fixed.
#[derive(Clone, Debug)]
pub struct Vulnerability {
  pub name: String,
  pub package: String,
  pub href: String,
  pub severity: Severity,
  pub fixes: Vec<Package>,
}

impl Vulnerability {
  /// Attempt to convert a `Description` into a `Vulnerability`.
  pub fn from_description(desc: Description) -> Result<Vulnerability, SemVerError> {
    let fixes = desc.fixes
      .into_iter()
      .map(|fix| Package::with_version_string(fix.name, fix.version))
      .collect::<Result<Vec<Package>, SemVerError>>()?;

    Ok(Vulnerability {
      name: desc.name,
      package: desc.package,
      href: desc.href,
      severity: desc.severity,
      fixes: fixes,
    })
  }
}

impl From<Vulnerability> for Description {
  fn from(vuln: Vulnerability) -> Self {
    Description {
      name: vuln.name,
      package: vuln.package,
      href: vuln.href,
      severity: vuln.severity,
      fixes: vuln.fixes.into_iter().map(From::from).collect(),
    }
  }
}
