use std::fmt;

use package::Package;
use vulnerability::{Severity, Vulnerability};
use vulnerability::clair::Platform;

use reqwest;


const DEFAULT_LIMIT: u16 = ::std::u16::MAX;

/// Contains a variant for each kind of error that may be encountered while
/// communicating with the Clair API.
#[derive(Debug)]
pub enum Error {
  /// The HTTP request could not be made or failed for some other reason.
  ClientError(reqwest::Error),

  /// The Clair API returned an error in a response to a request for information
  /// about a vulnerability for a platform.
  APIError(String),
}

/// Represents each of the Clair endpoints we will call into, including
/// parameters for each.
enum Endpoint<'ns> {
  ListVulnerabilities {
    namespace: &'ns str,
    limit: u16,
    page: Option<String>,
  },
  GetVulnerability {
    namespace: &'ns str,
    name: String,
  },
}

/// Represents the severity of vulnerabilities in the form the Clair API reports them in.
#[derive(Debug, Deserialize)]
enum ClairSeverity {
  Unknown,
  Negligable,
  Low,
  Medium,
  High,
  Critical,
  Defcon1,
}

#[derive(Debug, Deserialize)]
struct Fix {
  #[serde(rename = "Name")]
  pub name: String,
  #[serde(rename = "Version")]
  pub version: String,
}

#[derive(Debug, Clone, Deserialize)]
struct ShortVuln {
  #[serde(rename = "Name")]
  pub name: String,
}

#[derive(Debug, Deserialize)]
struct LongVuln {
  #[serde(rename = "Name")]
  pub name: String,
  #[serde(rename = "Link")]
  pub link: String,
  #[serde(rename = "Severity")]
  pub severity: ClairSeverity,
  #[serde(rename = "FixedIn")]
  pub fixed_in: Option<Vec<Fix>>,
}

#[derive(Debug, Deserialize)]
struct ErrorMessage {
  #[serde(rename = "Message")]
  pub message: String,
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum ShortVulnResponse {
  Error {
    #[serde(rename = "Error")]
    error: ErrorMessage,
  },
  Success {
    #[serde(rename = "Vulnerabilities")]
    vulns: Vec<ShortVuln>,
    #[serde(rename = "NextPage")]
    next_page: Option<String>,
  },
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum LongVulnResponse {
  Error {
    #[serde(rename = "Error")]
    error: ErrorMessage,
  },
  Success {
    #[serde(rename = "Vulnerability")]
    vuln: LongVuln,
  },
}

/// Fetch a list of vulnerabilities from the Clair v1 API.
pub fn list_all_vulnerabilities(base: &reqwest::Url, platform: &Platform) -> Result<Vec<Vulnerability>, Error> {
  let mut vuln_summaries = Vec::new();
  let mut next_page_opt: Option<String> = None;

  let namespace = format!("{}", platform);

  // The first step is to collect information about vulnerabilities affecting the namespace
  // we're interested in.
  loop {
    let list_vulns_endpt = Endpoint::ListVulnerabilities {
      namespace: &namespace,
      limit: DEFAULT_LIMIT,
      page: next_page_opt,
    };
    let list_vulns_url = base.join(&format!("{}", list_vulns_endpt)).unwrap();
    let response: ShortVulnResponse = reqwest::get(list_vulns_url)?.json()?;

    match response {
      ShortVulnResponse::Error{ error } => return Err(Error::APIError(error.message)),
      ShortVulnResponse::Success{ vulns, next_page } => {
        vuln_summaries.extend_from_slice(&vulns);
        next_page_opt = next_page;
      },
    }

    if next_page_opt.is_none() {
      break;
    }
  }

  // Second, we need to make a request to get all of the information associated with each vuln.
  vuln_summaries
    .into_iter()
    .map(|ShortVuln{ name, .. }| {
      let describe_vuln_endpt = Endpoint::GetVulnerability {
        namespace: &namespace,
        name: name,
      };
      let describe_vuln_url = base.join(&format!("{}", describe_vuln_endpt)).unwrap();
      let response: LongVulnResponse = reqwest::get(describe_vuln_url)?.json()?;

      match response {
        LongVulnResponse::Error{ error }  => Err(Error::APIError(error.message)),
        LongVulnResponse::Success{ vuln } => Ok(vuln),
      }
    })
    .filter(|get_vuln_result| match get_vuln_result {
      &Ok(LongVuln{ fixed_in: Some(ref fixes), .. }) => fixes.len() > 0,
      &Ok(_) => false,
      _ => true,
    })
    .map(|get_vuln_result|
      get_vuln_result.map(|LongVuln{ name, link, severity, fixed_in }| {
        let fixed_in = fixed_in.unwrap();
        let package_name = fixed_in[0].name.clone();
        let fixes: Vec<Package> = fixed_in
          .into_iter()
          .map(|fix| Package::new(fix.name, fix.version))
          .collect();

        Vulnerability {
          name: name,
          package: package_name,
          href: link,
          severity: From::from(severity),
          fixes: fixes,
        }
      }))
    .collect()
}

impl<'ns> fmt::Display for Endpoint<'ns> {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    match *self {
      Endpoint::ListVulnerabilities{ namespace, limit, page: Some(ref page) } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities?limit={}&page={}", namespace, limit, page),

      Endpoint::ListVulnerabilities{ namespace, limit, .. } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities?limit={}", namespace, limit),

      Endpoint::GetVulnerability{ namespace, ref name } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities/{}?fixedIn", namespace, name),
    }
  }
}

impl From<reqwest::Error> for Error {
  fn from(err: reqwest::Error) -> Self {
    Error::ClientError(err)
  }
}

impl From<ClairSeverity> for Severity {
  fn from(sev: ClairSeverity) -> Self {
    match sev {
      ClairSeverity::Unknown    => Severity::Unknown,
      ClairSeverity::Negligable => Severity::Negligable,
      ClairSeverity::Low        => Severity::Low,
      ClairSeverity::Medium     => Severity::Medium,
      ClairSeverity::High       => Severity::High,
      ClairSeverity::Critical   => Severity::Critical,
      ClairSeverity::Defcon1    => Severity::Urgent,
    }
  }
}

#[cfg(all(test, feature = "integration-test"))]
mod integration_test {
  use super::*;
  use vulnerability::clair::Platform;

  use reqwest;


  #[test]
  fn can_get_vulnerabilities() {
    let base_url = reqwest::Url::parse("http://clair:6060").unwrap();
    let platforms = vec![
      Platform::Debian(8),
      Platform::Alpine3(6),
      Platform::Ubuntu(16, 4),
    ];

    for platform in platforms {
      let vulns = list_all_vulnerabilities(&base_url, &platform)
        .expect("Should have been able to fetch vulns for debian 8 from Clair");
      assert!(vulns.len() > 0);
    }
  }
}
