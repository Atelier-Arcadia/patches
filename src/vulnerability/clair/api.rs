use std::fmt;
use std::collections::LinkedList;

use futures::{Context, Sink, Stream};
use futures::prelude::Async;
use reqwest::async::Client;
use reqwest::Url;

use package::Package;
use vulnerability::{Severity, Vulnerability};
use vulnerability::clair::{Error, Platform};


const DEFAULT_LIMIT: u16 = ::std::u16::MAX;

/// A simple descriptive alias for a "page," which denotes an offset into the list of
/// vulnerabilties we will fetch from Calir.
type Page = String;

/// Represents each of the Clair endpoints we will call into, including
/// parameters for each.
enum Endpoint<'ns> {
  ListVulnerabilities {
    namespace: &'ns str,
    limit: u16,
    page: Option<Page>,
  },
  GetVulnerability {
    namespace: &'ns str,
    name: String,
  },
}

/// Represents the severity of vulnerabilities in the form the Clair API reports them in.
#[derive(Debug, Deserialize)]
enum ClairSeverity {
  Unknown,
  Negligible,
  Low,
  Medium,
  High,
  Critical,
  Defcon1,
}

#[derive(Debug, Deserialize)]
struct Fix {
  #[serde(rename = "Name")]
  pub name: String,
  #[serde(rename = "Version")]
  pub version: String,
}

#[derive(Debug, Clone, Deserialize)]
struct ShortVuln {
  #[serde(rename = "Name")]
  pub name: String,
}

#[derive(Debug, Deserialize)]
struct LongVuln {
  #[serde(rename = "Name")]
  pub name: String,
  #[serde(rename = "Link")]
  pub link: String,
  #[serde(rename = "Severity")]
  pub severity: ClairSeverity,
  #[serde(rename = "FixedIn")]
  pub fixed_in: Option<Vec<Fix>>,
}

#[derive(Debug, Deserialize)]
struct ErrorMessage {
  #[serde(rename = "Message")]
  pub message: String,
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum ShortVulnResponse {
  Error {
    #[serde(rename = "Error")]
    error: ErrorMessage,
  },
  Success {
    #[serde(rename = "Vulnerabilities")]
    vulns: Vec<ShortVuln>,
    #[serde(rename = "NextPage")]
    next_page: Option<String>,
  },
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum LongVulnResponse {
  Error {
    #[serde(rename = "Error")]
    error: ErrorMessage,
  },
  Success {
    #[serde(rename = "Vulnerability")]
    vuln: LongVuln,
  },
}

/// Streams `ShortVuln`.
#[derive(Debug)]
struct ShortVulnStream {
  next_page: Option<Page>,
  base_address: Url,
  target: Platform,
}

/// Streams `Vulnerability` by acting as a `Sink` that reads from `ShortVulnStream`.
#[derive(Debug)]
struct VulnerabilityStream {
  platform: Platform,
  vuln_descriptions: LinkedList<ShortVuln>,
}

/// Fetch a list of vulnerabilities from the Clair v1 API.
pub fn list_all_vulnerabilities(
  base: &reqwest::Url,
  platform: &Platform
) -> Stream<Item = Vulnerability, Error = Error>
{
  let mut vuln_summaries = Vec::new();
  let mut next_page_opt: Option<String> = None;

  let namespace = format!("{}", platform);

  // The first step is to collect information about vulnerabilities affecting the namespace
  // we're interested in.
  loop {
    let list_vulns_endpt = Endpoint::ListVulnerabilities {
      namespace: &namespace,
      limit: DEFAULT_LIMIT,
      page: next_page_opt,
    };
    let list_vulns_url = base.join(&format!("{}", list_vulns_endpt)).unwrap();
    let response: ShortVulnResponse = reqwest::get(list_vulns_url)?.json()?;

    match response {
      ShortVulnResponse::Error{ error } => return Err(Error::APIError(error.message)),
      ShortVulnResponse::Success{ vulns, next_page } => {
        vuln_summaries.extend_from_slice(&vulns);
        next_page_opt = next_page;
      },
    }

    if next_page_opt.is_none() {
      break;
    }
  }

  // Second, we need to make a request to get all of the information associated with each vuln.
  vuln_summaries
    .into_iter()
    .map(|ShortVuln{ name, .. }| {
      let describe_vuln_endpt = Endpoint::GetVulnerability {
        namespace: &namespace,
        name: name,
      };
      let describe_vuln_url = base.join(&format!("{}", describe_vuln_endpt)).unwrap();
      let response: LongVulnResponse = reqwest::get(describe_vuln_url)?.json()?;

      match response {
        LongVulnResponse::Error{ error }  => Err(Error::APIError(error.message)),
        LongVulnResponse::Success{ vuln } => Ok(vuln),
      }
    })
    .filter(|get_vuln_result| match get_vuln_result {
      &Ok(LongVuln{ fixed_in: Some(ref fixes), .. }) => fixes.len() > 0,
      &Ok(_) => false,
      _ => true, // We don't want to swallow errors.
    })
    .map(|get_vuln_result|
      get_vuln_result.map(|LongVuln{ name, link, severity, fixed_in }| {
        let fixed_in = fixed_in.unwrap();
        let package_name = fixed_in[0].name.clone();
        let fixes: Vec<Package> = fixed_in
          .into_iter()
          .map(|fix| Package::new(fix.name, fix.version))
          .collect();

        Vulnerability {
          name: name,
          package: package_name,
          href: link,
          severity: From::from(severity),
          fixes: fixes,
        }
      }))
    .collect()
}

impl<'ns> fmt::Display for Endpoint<'ns> {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    match *self {
      Endpoint::ListVulnerabilities{ namespace, limit, page: Some(ref page) } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities?limit={}&page={}", namespace, limit, page),

      Endpoint::ListVulnerabilities{ namespace, limit, .. } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities?limit={}", namespace, limit),

      Endpoint::GetVulnerability{ namespace, ref name } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities/{}?fixedIn", namespace, name),
    }
  }
}

impl From<ClairSeverity> for Severity {
  fn from(sev: ClairSeverity) -> Self {
    match sev {
      ClairSeverity::Unknown    => Severity::Unknown,
      ClairSeverity::Negligible => Severity::Negligible,
      ClairSeverity::Low        => Severity::Low,
      ClairSeverity::Medium     => Severity::Medium,
      ClairSeverity::High       => Severity::High,
      ClairSeverity::Critical   => Severity::Critical,
      ClairSeverity::Defcon1    => Severity::Urgent,
    }
  }
}

impl Stream for ShortVulnStream {
  type Item = ShortVuln;
  type Error = Error;

  fn poll_next(&mut self, ctx: &mut Context) -> Result<Async<Option<Self::Item>>, Self::Error> {
    let client = Client::new();
    let namespace = format!("{}", self.target);
    let endpt = Endpoint::ListVulnerabilities {
      namespace: &namespace,
      limit: DEFAULT_LIMIT,
      page: self.next_page.clone(),
    };
    let list_vulns_url = self.base_address.join(&format!("{}", endpt)).unwrap();

    // I want to get the response out of here, parse the body, and stream out the result
    client.get(&list_vulns_url).send()
  }
}

impl Sink for VulnerabilityStream {
  type SinkItem = ShortVuln;
  type SinkError = Error;

  fn poll_ready(&mut self, ctx: &mut Context) -> Result<Async<()>, Self::SinkError> {
    Ok(Async::Ready(()))
  }

  fn start_send(&mut self, item: Self::SinkItem) -> Result<(), Self::SinkError> {
    self.vuln_descriptions.push_back(item);
    Ok(())
  }

  fn poll_flush(&mut self, ctx: &mut Context) -> Result<Async<()>, Self::SinkError> {
    Ok(Async::Ready(()))
  }

  fn poll_close(&mut self, ctx: &mut Context) -> Result<Async<()>, Self::SinkError> {
    Ok(Async::Ready(()))
  }
}

impl Stream for VulnerabilityStream {
  type Item = Vulnerability;
  type Error = Error;

  fn poll_next(&mut self, ctx: &mut Context) -> Result<Async<Option<Self::Item>>, Self::Error> {
  }
}

#[cfg(test)]
mod test {
  use super::*;

  use serde_json;


  #[test]
  fn can_decode_vulnerability_information() {
    let vuln_json_str = "{\"Vulnerability\":{\"Name\":\"CVE-2012-1954\",\"NamespaceName\":\"debian:8\",\"Description\":\"Use-after-free vulnerability in the nsDocument::AdoptNode function in Mozilla Firefox 4.x through 13.0, Firefox ESR 10.x before 10.0.6, Thunderbird 5.0 through 13.0, Thunderbird ESR 10.x before 10.0.6, and SeaMonkey before 2.11 allows remote attackers to cause a denial of service (heap memory corruption) or possibly execute arbitrary code via vectors involving multiple adoptions and empty documents.\",\"Link\":\"https://security-tracker.debian.org/tracker/CVE-2012-1954\",\"Severity\":\"High\",\"FixedIn\":[{\"Name\":\"icedove\",\"NamespaceName\":\"debian:8\",\"VersionFormat\":\"dpkg\",\"Version\":\"10.0.6-1\"}]}}";

    let vuln = match serde_json::from_str(vuln_json_str).unwrap() {
      LongVulnResponse::Error{ error }  => panic!(error.message),
      LongVulnResponse::Success{ vuln } => vuln,
    };
    let fixes = vuln.fixed_in.unwrap();

    assert!(vuln.name == "CVE-2012-1954".to_string());
    assert!(fixes.len() == 1);
    assert!(fixes[0].name == "icedove".to_string());
    assert!(fixes[0].version == "10.0.6-1".to_string());
  }
}

#[cfg(all(test, feature = "integration-test"))]
mod integration_test {
  use super::*;
  use vulnerability::clair::Platform;

  use reqwest;


  #[test]
  fn can_get_vulnerabilities() {
    let base_url = reqwest::Url::parse("http://clair:6060").unwrap();
    let platforms = vec![
      Platform::Debian(8),
      Platform::Alpine3(6),
      Platform::Ubuntu(16, 4),
    ];

    for platform in platforms {
      let vulns = list_all_vulnerabilities(&base_url, &platform)
        .expect(&format!("Should have been able to fetch vulns for {} from Clair", platform));
      assert!(vulns.len() > 0);
    }
  }
}
