use std::fmt;

use semver::SemVerError;

use package::Description as PackageDescription;
use vulnerability::{Description as VulnDescription, Severity, Vulnerability};

use reqwest;


const DEFAULT_LIMIT: u16 = ::std::u16::MAX;

/// Contains a variant for each kind of error that may be encountered while
/// communicating with the Clair API.
#[derive(Debug)]
pub enum Error {
  /// The version of a package description could not be parsed as a semantic
  /// version string.
  VersionFormatError(SemVerError),

  /// The HTTP request could not be made or failed for some other reason.
  ClientError(reqwest::Error),

  /// The Clair API returned an error in a response to a request for information
  /// about a vulnerability for a platform.
  APIError(String),
}

/// Represents each of the Clair endpoints we will call into, including
/// parameters for each.
enum Endpoint<'ns> {
  ListVulnerabilities {
    namespace: &'ns str,
    limit: u16,
    page: Option<String>,
  },
  GetVulnerability {
    namespace: &'ns str,
    name: String,
  },
}

#[derive(Debug, Clone, Deserialize)]
struct ShortVuln {
  #[serde(rename = "Name")]
  pub name: String,
}

#[derive(Debug, Deserialize)]
struct LongVuln {
  #[serde(rename = "Name")]
  pub name: String,
  #[serde(rename = "Link")]
  pub link: String,
  #[serde(rename = "Severity")]
  pub severity: Severity,
  #[serde(rename = "FixedIn")]
  pub fixed_in: Vec<PackageDescription>,
}

#[derive(Debug, Deserialize)]
struct ErrorMessage {
  #[serde(rename = "Message")]
  pub message: String,
}

#[derive(Debug, Deserialize)]
struct ShortVulnResponse {
  #[serde(rename = "Vulnerabilities")]
  pub vulns: Vec<ShortVuln>,
  #[serde(rename = "Error")]
  pub error: Option<ErrorMessage>,
  #[serde(rename = "NextPage")]
  pub next_page: String,
}

#[derive(Debug, Deserialize)]
struct LongVulnResponse {
  #[serde(rename = "Vulnerability")]
  pub vuln: LongVuln,
}

pub fn list_all_vulnerabilities(base: &reqwest::Url, namespace: String) -> Result<Vec<Vulnerability>, Error> {
  let mut vuln_summaries = Vec::new();
  let mut next_page_opt: Option<String> = None;

  let namespace = namespace.as_str();

  // The first step is to collect information about vulnerabilities affecting the namespace
  // we're interested in.
  loop {
    let list_vulns_endpt = Endpoint::ListVulnerabilities {
      namespace: namespace,
      limit: DEFAULT_LIMIT,
      page: next_page_opt,
    };
    let list_vulns_url = base.join(&format!("{}", list_vulns_endpt)).unwrap();

    let ShortVulnResponse{ vulns, error, next_page }  = reqwest::get(list_vulns_url)?.json()?;
    if let Some(ErrorMessage{ message }) = error {
      return Err(Error::APIError(message));
    }
    vuln_summaries.extend_from_slice(&vulns);
    if next_page.len() == 0 {
      break;
    }
    next_page_opt = Some(next_page);
  }

  // Second, we need to make a request to get all of the information associated with each vuln.
  vuln_summaries
    .into_iter()
    .map(|ShortVuln{ name, .. }| {
      let describe_vuln_endpt = Endpoint::GetVulnerability {
        namespace: namespace,
        name: name,
      };
      let describe_vuln_url = base.join(&format!("{}", describe_vuln_endpt)).unwrap();

      let LongVulnResponse{ vuln } = reqwest::get(describe_vuln_url)?.json()?;

      Ok(vuln)
    })
    .filter(|get_vuln_result| match get_vuln_result {
      Ok(ref vuln) => vuln.fixed_in.len() > 0,
      _ => true, // We don't want to swallow errors.
    })
    .map(|get_vuln_result| get_vuln_result.and_then(|LongVuln{ name, link, severity, fixed_in }|
      Vulnerability::from_description(VulnDescription {
        name: name,
        package: fixed_in[0].name.clone(),
        href: link,
        severity: severity,
        fixes: fixed_in,
      })
      .map_err(Error::VersionFormatError)))
    .collect()
}

impl<'ns> fmt::Display for Endpoint<'ns> {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    match *self {
      Endpoint::ListVulnerabilities{ namespace, limit, page: Some(ref page) } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities?limit={}&page={}", namespace, limit, page),

      Endpoint::ListVulnerabilities{ namespace, limit, .. } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities?limit={}", namespace, limit),

      Endpoint::GetVulnerability{ namespace, ref name } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities/{}?fixedIn", namespace, name),
    }
  }
}

impl From<reqwest::Error> for Error {
  fn from(err: reqwest::Error) -> Self {
    Error::ClientError(err)
  }
}

impl From<SemVerError> for Error {
  fn from(err: SemVerError) -> Self {
    Error::VersionFormatError(err)
  }
}
