use std::fmt;

use package::Package;
use vulnerability::{Severity, Vulnerability};
use vulnerability::clair::{Error, Platform};

use reqwest;


const DEFAULT_LIMIT: u16 = ::std::u16::MAX;


/// Represents each of the Clair endpoints we will call into, including
/// parameters for each.
enum Endpoint<'ns> {
  ListVulnerabilities {
    namespace: &'ns str,
    limit: u16,
    page: Option<String>,
  },
  GetVulnerability {
    namespace: &'ns str,
    name: String,
  },
}

/// Represents the severity of vulnerabilities in the form the Clair API reports them in.
#[derive(Debug, Deserialize)]
enum ClairSeverity {
  Unknown,
  Negligible,
  Low,
  Medium,
  High,
  Critical,
  Defcon1,
}

#[derive(Debug, Deserialize)]
struct Fix {
  #[serde(rename = "Name")]
  pub name: String,
  #[serde(rename = "Version")]
  pub version: String,
}

#[derive(Debug, Clone, Deserialize)]
struct ShortVuln {
  #[serde(rename = "Name")]
  pub name: String,
}

#[derive(Debug, Deserialize)]
struct LongVuln {
  #[serde(rename = "Name")]
  pub name: String,
  #[serde(rename = "Link")]
  pub link: String,
  #[serde(rename = "Severity")]
  pub severity: ClairSeverity,
  #[serde(rename = "FixedIn")]
  pub fixed_in: Option<Vec<Fix>>,
}

#[derive(Debug, Deserialize)]
struct ErrorMessage {
  #[serde(rename = "Message")]
  pub message: String,
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum ShortVulnResponse {
  Error {
    #[serde(rename = "Error")]
    error: ErrorMessage,
  },
  Success {
    #[serde(rename = "Vulnerabilities")]
    vulns: Vec<ShortVuln>,
    #[serde(rename = "NextPage")]
    next_page: Option<String>,
  },
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum LongVulnResponse {
  Error {
    #[serde(rename = "Error")]
    error: ErrorMessage,
  },
  Success {
    #[serde(rename = "Vulnerability")]
    vuln: LongVuln,
  },
}

/// Fetch a list of vulnerabilities from the Clair v1 API.
pub fn list_all_vulnerabilities(base: &reqwest::Url, platform: &Platform) -> Result<Vec<Vulnerability>, Error> {
  let mut vuln_summaries = Vec::new();
  let mut next_page_opt: Option<String> = None;

  let namespace = format!("{}", platform);

  // The first step is to collect information about vulnerabilities affecting the namespace
  // we're interested in.
  loop {
    let list_vulns_endpt = Endpoint::ListVulnerabilities {
      namespace: &namespace,
      limit: DEFAULT_LIMIT,
      page: next_page_opt,
    };
    let list_vulns_url = base.join(&format!("{}", list_vulns_endpt)).unwrap();
    let response: ShortVulnResponse = reqwest::get(list_vulns_url)?.json()?;

    match response {
      ShortVulnResponse::Error{ error } => return Err(Error::APIError(error.message)),
      ShortVulnResponse::Success{ vulns, next_page } => {
        vuln_summaries.extend_from_slice(&vulns);
        next_page_opt = next_page;
      },
    }

    if next_page_opt.is_none() {
      break;
    }
  }

  // Second, we need to make a request to get all of the information associated with each vuln.
  vuln_summaries
    .into_iter()
    .map(|ShortVuln{ name, .. }| {
      let describe_vuln_endpt = Endpoint::GetVulnerability {
        namespace: &namespace,
        name: name,
      };
      let describe_vuln_url = base.join(&format!("{}", describe_vuln_endpt)).unwrap();
      let response: LongVulnResponse = reqwest::get(describe_vuln_url)?.json()?;

      match response {
        LongVulnResponse::Error{ error }  => Err(Error::APIError(error.message)),
        LongVulnResponse::Success{ vuln } => Ok(vuln),
      }
    })
    .filter(|get_vuln_result| match get_vuln_result {
      &Ok(LongVuln{ fixed_in: Some(ref fixes), .. }) => fixes.len() > 0,
      &Ok(_) => false,
      _ => true, // We don't want to swallow errors.
    })
    .map(|get_vuln_result|
      get_vuln_result.map(|LongVuln{ name, link, severity, fixed_in }| {
        let fixed_in = fixed_in.unwrap();
        let package_name = fixed_in[0].name.clone();
        let fixes: Vec<Package> = fixed_in
          .into_iter()
          .map(|fix| Package::new(fix.name, fix.version))
          .collect();

        Vulnerability {
          name: name,
          package: package_name,
          href: link,
          severity: From::from(severity),
          fixes: fixes,
        }
      }))
    .collect()
}

impl<'ns> fmt::Display for Endpoint<'ns> {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    match *self {
      Endpoint::ListVulnerabilities{ namespace, limit, page: Some(ref page) } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities?limit={}&page={}", namespace, limit, page),

      Endpoint::ListVulnerabilities{ namespace, limit, .. } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities?limit={}", namespace, limit),

      Endpoint::GetVulnerability{ namespace, ref name } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities/{}?fixedIn", namespace, name),
    }
  }
}

impl From<ClairSeverity> for Severity {
  fn from(sev: ClairSeverity) -> Self {
    match sev {
      ClairSeverity::Unknown    => Severity::Unknown,
      ClairSeverity::Negligible => Severity::Negligible,
      ClairSeverity::Low        => Severity::Low,
      ClairSeverity::Medium     => Severity::Medium,
      ClairSeverity::High       => Severity::High,
      ClairSeverity::Critical   => Severity::Critical,
      ClairSeverity::Defcon1    => Severity::Urgent,
    }
  }
}

#[cfg(test)]
mod test {
  use super::*;

  use serde_json;


  #[test]
  fn can_decode_vulnerability_information() {
    let vuln_json_str = "{\"Vulnerability\":{\"Name\":\"CVE-2012-1954\",\"NamespaceName\":\"debian:8\",\"Description\":\"Use-after-free vulnerability in the nsDocument::AdoptNode function in Mozilla Firefox 4.x through 13.0, Firefox ESR 10.x before 10.0.6, Thunderbird 5.0 through 13.0, Thunderbird ESR 10.x before 10.0.6, and SeaMonkey before 2.11 allows remote attackers to cause a denial of service (heap memory corruption) or possibly execute arbitrary code via vectors involving multiple adoptions and empty documents.\",\"Link\":\"https://security-tracker.debian.org/tracker/CVE-2012-1954\",\"Severity\":\"High\",\"FixedIn\":[{\"Name\":\"icedove\",\"NamespaceName\":\"debian:8\",\"VersionFormat\":\"dpkg\",\"Version\":\"10.0.6-1\"}]}}";

    let vuln = match serde_json::from_str(vuln_json_str).unwrap() {
      LongVulnResponse::Error{ error }  => panic!(error.message),
      LongVulnResponse::Success{ vuln } => vuln,
    };
    let fixes = vuln.fixed_in.unwrap();

    assert!(vuln.name == "CVE-2012-1954".to_string());
    assert!(fixes.len() == 1);
    assert!(fixes[0].name == "icedove".to_string());
    assert!(fixes[0].version == "10.0.6-1".to_string());
  }
}

#[cfg(all(test, feature = "integration-test"))]
mod integration_test {
  use super::*;
  use vulnerability::clair::Platform;

  use reqwest;


  #[test]
  fn can_get_vulnerabilities() {
    let base_url = reqwest::Url::parse("http://clair:6060").unwrap();
    let platforms = vec![
      Platform::Debian(8),
      Platform::Alpine3(6),
      Platform::Ubuntu(16, 4),
    ];

    for platform in platforms {
      let vulns = list_all_vulnerabilities(&base_url, &platform)
        .expect(&format!("Should have been able to fetch vulns for {} from Clair", platform));
      assert!(vulns.len() > 0);
    }
  }
}
