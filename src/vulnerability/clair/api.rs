use std::fmt;

use futures::{Async, Future, Poll};
use futures::stream::Stream;
use reqwest;
use reqwest::Url;

use package::Package;
use vulnerability::{Severity, Source, Vulnerability};
use vulnerability::clair::{Clair, Error, Platform};


const DEFAULT_LIMIT: u16 = 100;

/// A simple descriptive alias for a "page," which denotes an offset into the list of
/// vulnerabilties we will fetch from Calir.
pub type Page = String;

/// Represents each of the Clair endpoints we will call into, including
/// parameters for each.
enum Endpoint<'ns> {
  ListVulnerabilities {
    namespace: &'ns str,
    limit: u16,
    page: Option<Page>,
  },
  GetVulnerability {
    namespace: &'ns str,
    name: String,
  },
}

/// Represents the severity of vulnerabilities in the form the Clair API reports them in.
#[derive(Debug, Deserialize)]
pub enum ClairSeverity {
  Unknown,
  Negligible,
  Low,
  Medium,
  High,
  Critical,
  Defcon1,
}

#[derive(Debug, Deserialize)]
struct Fix {
  #[serde(rename = "Name")]
  pub name: String,
  #[serde(rename = "Version")]
  pub version: String,
}

#[derive(Debug, Clone, Deserialize)]
struct ShortVuln {
  #[serde(rename = "Name")]
  pub name: String,
}

#[derive(Debug, Deserialize)]
struct LongVuln {
  #[serde(rename = "Name")]
  pub name: String,
  #[serde(rename = "Link")]
  pub link: String,
  #[serde(rename = "Severity")]
  pub severity: ClairSeverity,
  #[serde(rename = "FixedIn")]
  pub fixed_in: Option<Vec<Fix>>,
}

#[derive(Debug, Deserialize)]
struct ErrorMessage {
  #[serde(rename = "Message")]
  pub message: String,
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum ShortVulnResponse {
  Error {
    #[serde(rename = "Error")]
    error: ErrorMessage,
  },
  Success {
    #[serde(rename = "Vulnerabilities")]
    vulns: Vec<ShortVuln>,
    #[serde(rename = "NextPage")]
    next_page: Option<String>,
  },
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum LongVulnResponse {
  Error {
    #[serde(rename = "Error")]
    error: ErrorMessage,
  },
  Success {
    #[serde(rename = "Vulnerability")]
    vuln: LongVuln,
  },
}

/// A state tracker for `VulnState` that just provides more information than a boolean.
enum FirstRun {
  IsFirstRun,
  NotFirstRun,
}

/// State machine for a stream of vulnerability data.
///
/// # Specification
///
/// ```
///                    (1)                      (2)                       (3)
/// ,----------------,     ,------------------,     ,-------------------,     ,--------------------,
/// | FetchSummaries | --> | ResolveSummaries | --> | FetchDescriptions | --> | ResolveDescription |
/// '----------------'     '------------------'     '-------------------'     '--------------------'
///      |     ^                                         |        ^                      |
///      |     |                                         |        |                      |
///  (6) |     '-----------------------------------------'        '----------------------'
///      v                        (5)                                        (4)
/// .----------,
/// | Finished |
/// '----------'
/// ```
///
/// ## States
///
/// 1. `FetchSummaries` - The start state. It knows if it's been looped back to and if there are
///    more pages to fetch vuln summaries from.
/// 2. `ResolveSummaries` - A future resolving to a list of vuln summaries has been obtained
///    and is being resolved.
/// 3. `FetchDescriptions` - A list of vuln summaries has been obtained, so we need to request
///    details about the next vuln in that list.
/// 4. `ResolveDescription` - A future resolving to a complete description of a vulnerability has
///    been obtained and is being resolved.
/// 5. `Finished` - There are no more vulnerabilities to obtain information about.
///
/// Values are streamed out of the `ResolveDescription` state.
///
/// ## Transitions
///
/// 1. Occurs if `state.0 == false` or `state.1 == Some(Page)`.
/// 2. Occurs if `state.0.poll() == Ok(Async::Ready(Vec<ShortVuln>))`.
/// 3. Occurs if `state.0.len() > 0`.
/// 4. Occurs if `state.0.poll() == Ok(Async::Ready(LongVuln))`.
/// 5. Occurs if `state.0.len() == 0`.
/// 6. Occurs if `state.0 == true` and `state1. == None`.
enum VulnState {
  FetchSummaries(Clair, FirstRun, Option<Page>),
  ResolveSummaries(Clair, Box<Future<Item = (Vec<ShortVuln>, Option<Page>), Error = Error>>),
  FetchDescriptions(Clair, Vec<ShortVuln>, Option<Page>),
  ResolveDescription(Clair, Box<Future<Item = LongVuln, Error = Error>>, Vec<ShortVuln>, Option<Page>),
  Finished,
}

/// Implements the `Stream` trait to produce information about vulnerabilities.
pub struct VulnerabilityStream {
  state: Option<VulnState>,
}

/// Make a request to obtain the names of vulnerabilities that affect packages for a given platform.
fn vulnerability_summaries(
  base: &Url,
  platform: Platform,
  page: Option<Page>,
) -> Box<Future<Item = (Vec<ShortVuln>, Option<Page>), Error = Error>>
{
  let namespace = format!("{}", platform);
  let list_vulns_endpt = Endpoint::ListVulnerabilities {
    namespace: &namespace,
    limit: DEFAULT_LIMIT,
    page: page,
  };
  let list_vulns_url = base.join(&format!("{}", list_vulns_endpt)).unwrap();
  let client = reqwest::async::Client::new();

  println!("In vulnerability_summaries about to make request");
  println!("Requesting URL {}", list_vulns_url);

  Box::new(client
    .get(list_vulns_url)
    .send()
    .and_then(|mut res| res.json::<ShortVulnResponse>())
    .map_err(Error::ClientError)
    .and_then(|res| match res {
      ShortVulnResponse::Error{ error }              => Err(Error::APIError(error.message)),
      ShortVulnResponse::Success{ vulns, next_page } => Ok((vulns, next_page)),
    }))
}

/// Make a request for more information about a specific vulnerability.
fn describe_vulnerability(
  base: &Url,
  platform: Platform,
  vuln: &ShortVuln,
) -> Box<Future<Item = LongVuln, Error = Error>>
{
  let namespace = format!("{}", platform);
  let describe_vuln_endpt = Endpoint::GetVulnerability {
    namespace: &namespace,
    name: vuln.name.clone(),
  };
  let describe_vuln_url = base.join(&format!("{}", describe_vuln_endpt)).unwrap();
  let client = reqwest::async::Client::new();

  Box::new(client
    .get(describe_vuln_url)
    .send()
    .and_then(|mut res| res.json::<LongVulnResponse>())
    .map_err(Error::ClientError)
    .and_then(|res| match res {
      LongVulnResponse::Error{ error }  => Err(Error::APIError(error.message)),
      LongVulnResponse::Success{ vuln } => Ok(vuln),
    }))
}

impl VulnerabilityStream {
  /// Construct a new stream from which information about vulnerabilities affecting
  /// packages for a given platform are affected.
  pub fn new(config: Clair) -> Self {
    VulnerabilityStream {
      state: Some(VulnState::starting(config)),
    }
  }
}

impl VulnState {
  /// Create a new state machine for a `Vulnerability` stream.
  pub fn starting(config: Clair) -> Self {
    VulnState::FetchSummaries(config, FirstRun::IsFirstRun, None)
  }

  fn fs_to_rs(
    cfg: Clair,
    next_page: Option<Page>
  ) -> (Self, Poll<Option<Vulnerability>, Error>)
  {
    println!("In fs_to_rs");

    let fut = vulnerability_summaries(&cfg.base_address, cfg.target_platform, next_page);

    ( VulnState::ResolveSummaries(cfg, fut)
    , Ok(Async::NotReady)
    )
  }

  fn rs_to_fd_or_rs(
    cfg: Clair,
    mut future: Box<Future<Item = (Vec<ShortVuln>, Option<Page>), Error = Error>>
  ) -> (Self, Poll<Option<Vulnerability>, Error>)
  {
    println!("In rs_to_fd_or_rs");

    let poll_result = future.poll();

    match poll_result {
      Ok(Async::Ready((summaries, next_page))) =>
        ( VulnState::FetchDescriptions(cfg, summaries, next_page)
        , Ok(Async::NotReady)
        ),

      Ok(Async::NotReady) =>
        ( VulnState::ResolveSummaries(cfg, future)
        , Ok(Async::NotReady)
        ),

      Err(err) =>
        ( VulnState::ResolveSummaries(cfg, future)
        , Err(err)
        ),
    }
  }

  fn fd_to_rd_or_fs(
    cfg: Clair,
    mut vuln_summaries: Vec<ShortVuln>,
    next_page: Option<Page>
  ) -> (Self, Poll<Option<Vulnerability>, Error>) {
    println!("In fd_to_rd_or_fs");

    if vuln_summaries.len() == 0 {
      return VulnState::fd_to_fs(cfg, next_page);
    }

    let next_vuln = vuln_summaries.pop().unwrap();
    let fut = describe_vulnerability(&cfg.base_address, cfg.target_platform, &next_vuln);

    ( VulnState::ResolveDescription(cfg, fut, vuln_summaries, next_page)
    , Ok(Async::NotReady)
    )
  }

  fn fd_to_fs(cfg: Clair, next_page: Option<Page>) -> (Self, Poll<Option<Vulnerability>, Error>) {
    println!("In fd_to_fs");

    ( VulnState::FetchSummaries(cfg, FirstRun::NotFirstRun, next_page)
    , Ok(Async::NotReady)
    )
  }

  fn rd_to_fd(
    cfg: Clair,
    mut future: Box<Future<Item = LongVuln, Error = Error>>,
    vuln_summaries: Vec<ShortVuln>,
    next_page: Option<Page>
  ) -> (Self, Poll<Option<Vulnerability>, Error>)
  {
    println!("In rd_to_fd");

    let poll_result = future.poll();

    match poll_result {
      Ok(Async::Ready(long_vuln)) => {
        let LongVuln{ name, link, severity, fixed_in } = long_vuln;
        let next_state = VulnState::FetchDescriptions(cfg, vuln_summaries, next_page);

        if fixed_in.is_none() {
          return (next_state, Ok(Async::NotReady));
        }
        let fixes = fixed_in.unwrap();
        
        let package_name = fixes[0].name.clone();
        let fixes: Vec<Package> = fixes
          .into_iter()
          .map(|fix| Package::new(fix.name, fix.version))
          .collect();
        let vuln = Vulnerability {
          name: name,
          package: package_name,
          href: link,
          severity: From::from(severity),
          fixes: fixes,
        };

        (next_state, Ok(Async::Ready(Some(vuln))))
      },

      Ok(Async::Ready(_)) =>
        ( VulnState::FetchDescriptions(cfg, vuln_summaries, next_page)
        , Ok(Async::NotReady)
        ),

      Ok(Async::NotReady) =>
        ( VulnState::ResolveDescription(cfg, future, vuln_summaries, next_page)
        , Ok(Async::NotReady)
        ),
      
      Err(err)  =>
        ( VulnState::ResolveDescription(cfg, future, vuln_summaries, next_page)
        , Err(err)
        ),
    }
  }

  fn finished() -> (Self, Poll<Option<Vulnerability>, Error>) {
    println!("In finished");

    ( VulnState::Finished
    , Ok(Async::Ready(None))
    )
  }
}

impl Stream for VulnerabilityStream 
{
  type Item = Vulnerability;
  type Error = Error;

  fn poll(&mut self) -> Poll<Option<Self::Item>, Self::Error> {
    use self::VulnState::*;
    use self::FirstRun::*;

    println!("In poll");

    let state = self.state.take().unwrap();

    let (new_state, response) = match state {
      FetchSummaries(c, NotFirstRun, None)   => VulnState::finished(),
      FetchSummaries(c, _, page)             => VulnState::fs_to_rs(c, page),
      ResolveSummaries(c, fut)               => VulnState::rs_to_fd_or_rs(c, fut),
      FetchDescriptions(c, sums, page)       => VulnState::fd_to_rd_or_fs(c, sums, page),
      ResolveDescription(c, fut, sums, page) => VulnState::rd_to_fd(c, fut, sums, page),
      Finished                               => VulnState::finished(),
    };

    self.state = Some(new_state);

    response
  }
}

impl Source<Error> for VulnerabilityStream{}

impl<'ns> fmt::Display for Endpoint<'ns> {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    match *self {
      Endpoint::ListVulnerabilities{ namespace, limit, page: Some(ref page) } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities?limit={}&page={}", namespace, limit, page),

      Endpoint::ListVulnerabilities{ namespace, limit, .. } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities?limit={}", namespace, limit),

      Endpoint::GetVulnerability{ namespace, ref name } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities/{}?fixedIn", namespace, name),
    }
  }
}

impl From<ClairSeverity> for Severity {
  fn from(sev: ClairSeverity) -> Self {
    match sev {
      ClairSeverity::Unknown    => Severity::Unknown,
      ClairSeverity::Negligible => Severity::Negligible,
      ClairSeverity::Low        => Severity::Low,
      ClairSeverity::Medium     => Severity::Medium,
      ClairSeverity::High       => Severity::High,
      ClairSeverity::Critical   => Severity::Critical,
      ClairSeverity::Defcon1    => Severity::Urgent,
    }
  }
}


#[cfg(test)]
mod test {
  use super::*;

  use serde_json;


  #[test]
  fn can_decode_vulnerability_information() {
    let vuln_json_str = "{\"Vulnerability\":{\"Name\":\"CVE-2012-1954\",\"NamespaceName\":\"debian:8\",\"Description\":\"Use-after-free vulnerability in the nsDocument::AdoptNode function in Mozilla Firefox 4.x through 13.0, Firefox ESR 10.x before 10.0.6, Thunderbird 5.0 through 13.0, Thunderbird ESR 10.x before 10.0.6, and SeaMonkey before 2.11 allows remote attackers to cause a denial of service (heap memory corruption) or possibly execute arbitrary code via vectors involving multiple adoptions and empty documents.\",\"Link\":\"https://security-tracker.debian.org/tracker/CVE-2012-1954\",\"Severity\":\"High\",\"FixedIn\":[{\"Name\":\"icedove\",\"NamespaceName\":\"debian:8\",\"VersionFormat\":\"dpkg\",\"Version\":\"10.0.6-1\"}]}}";

    let vuln = match serde_json::from_str(vuln_json_str).unwrap() {
      LongVulnResponse::Error{ error }  => panic!(error.message),
      LongVulnResponse::Success{ vuln } => vuln,
    };
    let fixes = vuln.fixed_in.unwrap();

    assert!(vuln.name == "CVE-2012-1954".to_string());
    assert!(fixes.len() == 1);
    assert!(fixes[0].name == "icedove".to_string());
    assert!(fixes[0].version == "10.0.6-1".to_string());
  }
}

#[cfg(all(test, feature = "integration-test"))]
mod integration_test {
  use super::*;
  use vulnerability::clair::{Clair, Platform};

  use futures::executor::spawn;
  use reqwest;


  #[test]
  fn can_get_vulnerabilities() {
    let base_url = reqwest::Url::parse("http://127.0.0.1:6060").unwrap();
    let platform = Platform::Debian(8);
    let stream = Clair::new(base_url, platform).into_source();
    let mut handle = spawn(stream);

    for _ in 0..3 {
      let vuln = handle.wait_stream().unwrap().unwrap();
      assert!(vuln.name.len() > 0);
    }
  }
}
