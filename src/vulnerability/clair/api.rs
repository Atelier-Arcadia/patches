use std::fmt;

use futures::{Async, Future, Poll};
use futures::stream::Stream;
use reqwest;
use reqwest::Url;

use package::Package;
use vulnerability::{Severity, Source, Vulnerability};
use vulnerability::clair::{Clair, Error, Platform};


const DEFAULT_LIMIT: u16 = ::std::u16::MAX;

/// A simple descriptive alias for a "page," which denotes an offset into the list of
/// vulnerabilties we will fetch from Calir.
pub type Page = String;

/// Represents each of the Clair endpoints we will call into, including
/// parameters for each.
enum Endpoint<'ns> {
  ListVulnerabilities {
    namespace: &'ns str,
    limit: u16,
    page: Option<Page>,
  },
  GetVulnerability {
    namespace: &'ns str,
    name: String,
  },
}

/// Represents the severity of vulnerabilities in the form the Clair API reports them in.
#[derive(Debug, Deserialize)]
enum ClairSeverity {
  Unknown,
  Negligible,
  Low,
  Medium,
  High,
  Critical,
  Defcon1,
}

#[derive(Debug, Deserialize)]
struct Fix {
  #[serde(rename = "Name")]
  pub name: String,
  #[serde(rename = "Version")]
  pub version: String,
}

#[derive(Debug, Clone, Deserialize)]
pub struct ShortVuln {
  #[serde(rename = "Name")]
  pub name: String,
}

#[derive(Debug, Deserialize)]
pub struct LongVuln {
  #[serde(rename = "Name")]
  pub name: String,
  #[serde(rename = "Link")]
  pub link: String,
  #[serde(rename = "Severity")]
  pub severity: ClairSeverity,
  #[serde(rename = "FixedIn")]
  pub fixed_in: Option<Vec<Fix>>,
}

#[derive(Debug, Deserialize)]
struct ErrorMessage {
  #[serde(rename = "Message")]
  pub message: String,
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum ShortVulnResponse {
  Error {
    #[serde(rename = "Error")]
    error: ErrorMessage,
  },
  Success {
    #[serde(rename = "Vulnerabilities")]
    vulns: Vec<ShortVuln>,
    #[serde(rename = "NextPage")]
    next_page: Option<String>,
  },
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum LongVulnResponse {
  Error {
    #[serde(rename = "Error")]
    error: ErrorMessage,
  },
  Success {
    #[serde(rename = "Vulnerability")]
    vuln: LongVuln,
  },
}

/// A state tracker for `VulnState` that just provides more information than a boolean.
pub enum FirstRun {
  IsFirstRun,
  NotFirstRun,
}

/// State machine for a stream of vulnerability data.
///
/// # Specification
///
/// ```
///                    (1)                      (2)                       (3)
/// ,----------------,     ,------------------,     ,-------------------,     ,--------------------,
/// | FetchSummaries | --> | ResolveSummaries | --> | FetchDescriptions | --> | ResolveDescription |
/// '----------------'     '------------------'     '-------------------'     '--------------------'
///      |     ^                                         |        ^                      |
///      |     |                                         |        |                      |
///  (6) |     '-----------------------------------------'        '----------------------'
///      v                        (5)                                        (4)
/// .----------,
/// | Finished |
/// '----------'
/// ```
///
/// ## States
///
/// 1. `FetchSummaries` - The start state. It knows if it's been looped back to and if there are
///    more pages to fetch vuln summaries from.
/// 2. `ResolveSummaries` - A future resolving to a list of vuln summaries has been obtained
///    and is being resolved.
/// 3. `FetchDescriptions` - A list of vuln summaries has been obtained, so we need to request
///    details about the next vuln in that list.
/// 4. `ResolveDescription` - A future resolving to a complete description of a vulnerability has
///    been obtained and is being resolved.
/// 5. `Finished` - There are no more vulnerabilities to obtain information about.
///
/// Values are streamed out of the `ResolveDescription` state.
///
/// ## Transitions
///
/// 1. Occurs if `state.0 == false` or `state.1 == Some(Page)`.
/// 2. Occurs if `state.0.poll() == Ok(Async::Ready(Vec<ShortVuln>))`.
/// 3. Occurs if `state.0.len() > 0`.
/// 4. Occurs if `state.0.poll() == Ok(Async::Ready(LongVuln))`.
/// 5. Occurs if `state.0.len() == 0`.
/// 6. Occurs if `state.0 == true` and `state1. == None`.
pub enum VulnState<V1, V2> {
  FetchSummaries(Clair, FirstRun, Option<Page>),
  ResolveSummaries(Clair, V1),
  FetchDescriptions(Clair, Vec<ShortVuln>, Option<Page>),
  ResolveDescription(Clair, V2, Vec<ShortVuln>, Option<Page>),
  Finished,
}

/// Make a request to obtain the names of vulnerabilities that affect packages for a given platform.
fn vulnerability_summaries(
  base: &Url,
  platform: Platform,
  page: Option<Page>,
) -> impl Future<Item = (Vec<ShortVuln>, Option<Page>), Error = Error>
{
  let namespace = format!("{}", platform);
  let list_vulns_endpt = Endpoint::ListVulnerabilities {
    namespace: &namespace,
    limit: DEFAULT_LIMIT,
    page: page,
  };
  let list_vulns_url = base.join(&format!("{}", list_vulns_endpt)).unwrap();
  let client = reqwest::async::Client::new();

  client
    .get(list_vulns_url)
    .send()
    .and_then(|mut res| res.json::<ShortVulnResponse>())
    .map_err(Error::ClientError)
    .and_then(|res| match res {
      ShortVulnResponse::Error{ error }              => Err(Error::APIError(error.message)),
      ShortVulnResponse::Success{ vulns, next_page } => Ok((vulns, next_page)),
    })
}

/// Make a request for more information about a specific vulnerability.
fn describe_vulnerability(
  base: &Url,
  platform: Platform,
  vuln: &ShortVuln,
) -> impl Future<Item = LongVuln, Error = Error>
{
  let namespace = format!("{}", platform);
  let describe_vuln_endpt = Endpoint::GetVulnerability {
    namespace: &namespace,
    name: vuln.name,
  };
  let describe_vuln_url = base.join(&format!("{}", describe_vuln_endpt)).unwrap();
  let client = reqwest::async::Client::new();

  client
    .get(describe_vuln_url)
    .send()
    .and_then(|mut res| res.json::<LongVulnResponse>())
    .map_err(Error::ClientError)
    .and_then(|res| match res {
      LongVulnResponse::Error{ error }  => Err(Error::APIError(error.message)),
      LongVulnResponse::Success{ vuln } => Ok(vuln),
    })
}

impl<V1, V2> VulnState<V1, V2> 
  where V1: Future<Item = (Vec<ShortVuln>, Option<Page>), Error = Error>,
        V2: Future<Item = LongVuln, Error = Error>,
{
  /// Create a new state machine for a `Vulnerability` stream.
  pub fn starting(config: Clair) -> Self {
    VulnState::FetchSummaries(config, FirstRun::IsFirstRun, None)
  }

  fn fs_to_rs(cfg: Clair, next_page: Option<Page>) -> (Self, Poll<Option<Vulnerability>, Error>) {
    let fut = vulnerability_summaries(&cfg.base_address, cfg.target_platform, next_page);

    ( VulnState::ResolveSummaries(cfg, fut)
    , Ok(Async::NotReady)
    )
  }

  fn rs_to_fd(cfg: Clair, future: V1) -> (Self, Poll<Option<Vulnerability>, Error>) {
    let poll_result = future.poll();

    match poll_result {
      Ok(Async::Ready((summaries, next_page))) =>
        ( VulnState::FetchDescriptions(cfg, summaries, next_page)
        , Ok(Async::NotReady)
        ),

      Ok(Async::NotReady) =>
        ( VulnState::ResolveSummaries(cfg, future)
        , Ok(Async::NotReady)
        ),

      Err(err) =>
        ( VulnState::ResolveSummaries(cfg, future)
        , Err(err)
        ),
    }
  }

  fn fd_to_rd(
    cfg: Clair,
    mut vuln_summaries: Vec<ShortVuln>,
    next_page: Option<Page>
  ) -> (Self, Poll<Option<Vulnerability>, Error>) {
    let next_vuln = vuln_summaries.pop().unwrap();
    let fut = describe_vulnerability(&cfg.base_address, cfg.target_platform, &next_vuln);

    ( VulnState::ResolveDescription(cfg, fut, vuln_summaries, next_page)
    , Ok(Async::NotReady)
    )
  }

  fn fd_to_fs(cfg: Clair, next_page: Option<Page>) -> (Self, Poll<Option<Vulnerability>, Error>) {
    ( VulnState::FetchSummaries(cfg, FirstRun::NotFirstRun, next_page)
    , Ok(Async::NotReady)
    )
  }

  fn rd_to_fd(
    cfg: Clair,
    future: V2,
    vuln_summaries: Vec<ShortVuln>,
    next_page: Option<Page>
  ) -> (Self, Poll<Option<Vulnerability>, Error>)
  {
    let poll_result = future.poll();

    match poll_result {
      Ok(Async::Ready(LongVuln{ name, link, severity, fixed_in: Some(fixes) })) if fixes.len() > 0 => {
        let next_state = VulnState::FetchDescriptions(cfg, vuln_summaries, next_page);
        let package_name = fixes[0].name.clone();
        let fixes: Vec<Package> = fixes
          .into_iter()
          .map(|fix| Package::new(fix.name, fix.version))
          .collect();
        let vuln = Vulnerability {
          name: name,
          package: package_name,
          href: link,
          severity: From::from(severity),
          fixes: fixes,
        };

        (next_state, Ok(Async::Ready(Some(vuln))))
      },

      Ok(Async::Ready(_)) =>
        ( VulnState::FetchDescriptions(cfg, vuln_summaries, next_page)
        , Ok(Async::NotReady)
        ),

      Ok(Async::NotReady) =>
        ( VulnState::ResolveDescription(cfg, future, vuln_summaries, next_page)
        , Ok(Async::NotReady)
        ),
      
      Err(err)  =>
        ( VulnState::ResolveDescription(cfg, future, vuln_summaries, next_page)
        , Err(err)
        ),
    }
  }

  fn finished() -> (Self, Poll<Option<Vulnerability>, Error>) {
    ( VulnState::Finished
    , Ok(Async::Ready(None))
    )
  }
}

impl<V1, V2> Stream for VulnState<V1, V2>
  where V1: Future<Item = (Vec<ShortVuln>, Option<Page>), Error = Error>,
        V2: Future<Item = LongVuln, Error = Error>,
{
  type Item = Vulnerability;
  type Error = Error;

  fn poll(&mut self) -> Poll<Option<Self::Item>, Self::Error> {
    use self::VulnState::*;
    use self::FirstRun::*;

    let (new_state, response) = match *self {
      FetchSummaries(c, NotFirstRun, _)                   => VulnState::fs_to_rs(c, None),
      FetchSummaries(c, FirstRun, page) if page.is_some() => VulnState::fs_to_rs(c, page),
      FetchSummaries(c, FirstRun, None)                   => VulnState::finished(),
      ResolveSummaries(c, fut)                            => VulnState::rs_to_fd(c, fut),
      FetchDescriptions(c, sums, page) if sums.len() > 0  => VulnState::fd_to_rd(c, sums, page),
      FetchDescriptions(c, sums, page) if sums.len() == 0 => VulnState::fd_to_fs(c, page),
      ResolveDescription(c, fut, sums, page)              => VulnState::rd_to_fd(c, fut, sums, page),
      Finished                                            => VulnState::finished(),
    };

    *self = new_state;

    response
  }
}

impl<V1, V2> Source<Error> for VulnState<V1, V2>
  where V1: Future<Item = (Vec<ShortVuln>, Option<Page>), Error = Error>,
        V2: Future<Item = LongVuln, Error = Error>,
{
}

impl<'ns> fmt::Display for Endpoint<'ns> {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    match *self {
      Endpoint::ListVulnerabilities{ namespace, limit, page: Some(ref page) } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities?limit={}&page={}", namespace, limit, page),

      Endpoint::ListVulnerabilities{ namespace, limit, .. } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities?limit={}", namespace, limit),

      Endpoint::GetVulnerability{ namespace, ref name } =>
        write!(f, "/v1/namespaces/{}/vulnerabilities/{}?fixedIn", namespace, name),
    }
  }
}

impl From<ClairSeverity> for Severity {
  fn from(sev: ClairSeverity) -> Self {
    match sev {
      ClairSeverity::Unknown    => Severity::Unknown,
      ClairSeverity::Negligible => Severity::Negligible,
      ClairSeverity::Low        => Severity::Low,
      ClairSeverity::Medium     => Severity::Medium,
      ClairSeverity::High       => Severity::High,
      ClairSeverity::Critical   => Severity::Critical,
      ClairSeverity::Defcon1    => Severity::Urgent,
    }
  }
}


#[cfg(test)]
mod test {
  use super::*;

  use serde_json;


  #[test]
  fn can_decode_vulnerability_information() {
    let vuln_json_str = "{\"Vulnerability\":{\"Name\":\"CVE-2012-1954\",\"NamespaceName\":\"debian:8\",\"Description\":\"Use-after-free vulnerability in the nsDocument::AdoptNode function in Mozilla Firefox 4.x through 13.0, Firefox ESR 10.x before 10.0.6, Thunderbird 5.0 through 13.0, Thunderbird ESR 10.x before 10.0.6, and SeaMonkey before 2.11 allows remote attackers to cause a denial of service (heap memory corruption) or possibly execute arbitrary code via vectors involving multiple adoptions and empty documents.\",\"Link\":\"https://security-tracker.debian.org/tracker/CVE-2012-1954\",\"Severity\":\"High\",\"FixedIn\":[{\"Name\":\"icedove\",\"NamespaceName\":\"debian:8\",\"VersionFormat\":\"dpkg\",\"Version\":\"10.0.6-1\"}]}}";

    let vuln = match serde_json::from_str(vuln_json_str).unwrap() {
      LongVulnResponse::Error{ error }  => panic!(error.message),
      LongVulnResponse::Success{ vuln } => vuln,
    };
    let fixes = vuln.fixed_in.unwrap();

    assert!(vuln.name == "CVE-2012-1954".to_string());
    assert!(fixes.len() == 1);
    assert!(fixes[0].name == "icedove".to_string());
    assert!(fixes[0].version == "10.0.6-1".to_string());
  }
}

#[cfg(all(test, feature = "integration-test"))]
mod integration_test {
  use super::*;
  use vulnerability::clair::Platform;

  use reqwest;


  #[test]
  fn can_get_vulnerabilities() {
    let base_url = reqwest::Url::parse("http://clair:6060").unwrap();
    let platforms = vec![
      Platform::Debian(8),
      Platform::Alpine3(6),
      Platform::Ubuntu(16, 4),
    ];

    for platform in platforms {
      let vulns = list_all_vulnerabilities(&base_url, &platform)
        .expect(&format!("Should have been able to fetch vulns for {} from Clair", platform));
      assert!(vulns.len() > 0);
    }
  }
}
