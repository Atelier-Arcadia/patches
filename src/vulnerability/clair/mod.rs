mod api;

use std::fmt;

use reqwest::{Error as RequestError, Url};

use vulnerability::{Source, Vulnerability};


/// A vulnerability source that draws information from the Clair API.
pub struct Clair {
  base_address: Url,
  target_platform: Platform,
}

/// Represents each of the "namespaces" that we can query Clair for.
#[derive(Debug, Clone, Copy)]
pub enum Platform {
  Debian(u8),
  DebianUnstable,
  Alpine3(u8),
  Ubuntu(u8, u8),
  CentOS(u8),
  Oracle(u8),
}

/// Contains a variant for each kind of error that may be encountered while
/// communicating with the Clair API.
#[derive(Debug)]
pub enum Error {
  /// The HTTP request could not be made or failed for some other reason.
  ClientError(RequestError),

  /// The Clair API returned an error in a response to a request for information
  /// about a vulnerability for a platform.
  APIError(String),
}

impl Clair {
  /// Construct a new `Clair` client with a base URL pointing to the API.
  pub fn new(base_addr: Url, target: Platform) -> Self {
    Clair {
      base_address: base_addr,
      target_platform: target,
    }
  }
}

impl fmt::Display for Platform {
  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    match *self {
      Platform::Debian(ver)          => write!(f, "debian:{}", ver),
      Platform::DebianUnstable       => write!(f, "debian:unstable"),
      Platform::Alpine3(ver)         => write!(f, "alpine:v3.{}", ver),
      Platform::Ubuntu(major, minor) => write!(f, "ubuntu:{}.{}", major, minor),
      Platform::CentOS(ver)          => write!(f, "centos:{}", ver),
      Platform::Oracle(ver)          => write!(f, "oracle:{}", ver),
    }
  }
}

impl Source for Clair {
  type Error = Error;

  fn query(&mut self) -> Result<Vec<Vulnerability>, Self::Error> {
    api::list_all_vulnerabilities(&self.base_address, &self.target_platform)
  }
}

impl From<RequestError> for Error {
  fn from(err: RequestError) -> Self {
    Error::ClientError(err)
  }
}
