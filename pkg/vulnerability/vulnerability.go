package vulnerability

import (
	"encoding/json"

	"github.com/arcrose/patches/pkg/done"
	"github.com/arcrose/patches/pkg/pack"
	"github.com/arcrose/patches/pkg/platform"
)

// Source describes types that can serve a stream of information about
// vulnerabilities affecting software packages.
//
// The contract that a Source should satisfy is as such:
// 1. When the done channel is written to, both the Vulnerability and
//    error channels should be considered closed and not read from again.
// 2. Any number of vulnenrabilities and errors can be written before
//    done is written to.
// 3. Only vulnerabilities that have been patched will be streamed, as
//    these are the only ones we can act on.
type Source interface {
	Vulnerabilities(platform.Platform) Job
}

// Job contains the channels from which vulnerabilities and progress can
// be retreived from a Source.
type Job struct {
	Vulns    chan Vulnerability
	Finished chan done.Done
	Errors   chan error
}

// Vulnerability describes a vulnerability affecting a package
type Vulnerability struct {
	Name                 string         `json:"name"`
	AffectedPackageName  string         `json:"affectedPackageName"`
	AffectedPlatformName string         `json:"affectedPlatform"`
	DetailsHref          string         `json:"detailsHref"`
	SeverityRating       Severity       `json:"severityRating"`
	FixedInPackages      []pack.Package `json:"fixedInPackages"`
}

// Severity enumerates the levels of severity that a vulnerability can be
// rated with.
type Severity uint8

const (
	SeverityUnknown    Severity = iota
	SeverityNegligible Severity = iota
	SeverityLow        Severity = iota
	SeverityMedium     Severity = iota
	SeverityHigh       Severity = iota
	SeverityCritical   Severity = iota
	SeverityUrgent     Severity = iota
)

// Equals determines whether two vulnerabilities contain the same data.
func (vuln Vulnerability) Equals(other Vulnerability) bool {
	if len(vuln.FixedInPackages) != len(other.FixedInPackages) {
		return false
	}
	for _, p1 := range vuln.FixedInPackages {
		found := false
		for _, p2 := range other.FixedInPackages {
			if p1.Equals(p2) {
				found = true
				break
			}
		}
		if !found {
			return false
		}
	}

	return vuln.Name == other.Name &&
		vuln.AffectedPackageName == other.AffectedPackageName &&
		vuln.AffectedPlatformName == other.AffectedPlatformName &&
		vuln.DetailsHref == other.DetailsHref &&
		vuln.SeverityRating == other.SeverityRating
}

// String produces a textual representation of a vulnerability as JSON.
func (vuln Vulnerability) String() string {
	encoded, _ := json.Marshal(vuln)
	return string(encoded)
}
